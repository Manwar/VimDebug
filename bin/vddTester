#!/usr/bin/env perl
#
# vddTester
# Vim Debugger Daemon Tester
#
# (c) eric johnson 2002-3020
# email: vimDebug at iijo dot org
# http://iijo.org
# PODNAME: vddTester
# ABSTRACT: Tests the vdd program.

use strict;
use warnings;
use Cwd;
use File::Basename;
use IO::Socket;
use POSIX ();
use Term::ANSIColor;
use Term::ReadLine;

# constants
my $PROTO      = "tcp";
my $HOST       = "localhost";
my $PORT       = "6543";
my $EOM_REGEX  = "\nvimdebug.eom\n"; # End Of Message Regular Expression
my $EOM_LEN    = length($EOM_REGEX); # length of $EOM
my $EOR_REGEX  = '\[vimdebug.eor\]'; # End Of Record Regular Expression

my ($debuggerName, @debuggerCommand, $term, $remote); 


init();
main();


sub usage {
   print "
usage: vddTester DEBUGGER DEBUGGER COMMAND

A test shell for the vim debugger daemon.  Invocation is weird because it
doesn't want quotes around the DEBUGGER COMMAND.  This is so tab completion
works.

example: vddTester Perl perl -Ilib -d t/perl.pl

"; exit(0);
}

sub initializeReadLine {
   $term = new Term::ReadLine('sanity');
   $term->ornaments(0);

   if($term->ReadLine eq 'Term::ReadLine::Gnu') {
      # Term::ReadLine::Gnu specific setup
   }

   if ($term->ReadLine eq 'Term::ReadLine::Stub') {
      warn("neither Term::ReadLine::Gnu or Term::ReadLine::Perl are installed.\n"
        . "please install from CPAN to enable command history or line " 
        . "editing\n")
   }
}

sub init {
   usage() unless(scalar(@ARGV) >= 2);
   $debuggerName    = shift @ARGV; # which debugger to use
   @debuggerCommand = @ARGV;       # debugger command
   initializeReadLine();
}

sub spawn {
   my @incantation = @_ or die;

   die "cannot fork" unless(defined(my $PID = fork));
   if($PID == 0) {
      exec(@incantation) or die "failed to run " . join(' ', @incantation);
   }
}

sub cnnct {
   foreach my $i (0..9) {
      $remote = IO::Socket::INET->new(
         Proto    => $PROTO,
         PeerAddr => $HOST,
         PeerPort => $PORT,
      ) and last;
      sleep 1;
   }

   die ("could not connect to port $PORT") if !defined $remote;

   print color("white"), "connected to port $PORT\n";
}

sub snd {
   my $data = shift;
   print $remote $data . "\n";
   if ($data eq "quit") {
      close $remote;
      exit();
   }
}

sub rcv {
   my $data = '';
   ($data .= <$remote>) until substr($data, -1 * $EOM_LEN) eq $EOM_REGEX;
   $data = substr($data, 0, -1 * $EOM_LEN);
   my ($status, $line, $file, $output) = split($EOR_REGEX, $data);
   print color("bright_green"), "status: $status\n";
   print color("bright_green"), "line:   $line\n";
   print color("bright_green"), "file:   $file\n";
   print color("green"), $output, "\n";
}

sub main {
   spawn("vdd $debuggerName @debuggerCommand");
   cnnct();
   rcv();

   # loop until user asks to quit
   while(1) {
      my $command = $term->readline(color("white") . "vdd:$debuggerName> ");
         $command = "quit" unless defined $command;

      for ($command)   {
         /^n$/           and $command = "next";
         /^s$/           and $command = "step";
         /^c$/           and $command = "cont";
         /^q$/           and $command = "quit";
         /^r$/           and $command = "restart";
         /^b (.+)$/      and $command = "break:$1:sourcepath";
         /^B (.+)$/      and $command = "clear:$1:sourcepath";
         /^l (.+)$/      and $command = "clearAll";
         /^p (.+)$/      and $command = "printExpression:$1";
         /^d (.+)$/      and $command = "command:$1";
      }

      snd($command);
      rcv();
   }
}

sub END {
   print color("white"), "\n";
}

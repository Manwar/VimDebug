#!/usr/bin/env perl
#
# vddTester
# Vim Debugger Daemon Tester
#
# (c) eric johnson 2002-3020
# email: vimDebug at iijo dot org
# http://iijo.org
# PODNAME: vddTester
# ABSTRACT: Tests the vdd program.

use strict;
use warnings;
use Cwd;
use File::Basename;
use POSIX ();
use Term::ANSIColor;
use Term::ReadLine;

my ($sessionId, $sourcePath, $debuggerName, @debuggerCommand); 
my ($ctl_vddFIFOvim, $ctl_vimFIFOvdd, $dbg_vddFIFOvim);
my ($term, $PID, $prevCommand);


init();
main();


sub getCommandLineOptions {
   usage() unless(scalar(@ARGV) >= 4);

   $sessionId          = int(rand(99999));
   $debuggerName       = shift @ARGV or die;
   @debuggerCommand    = @ARGV or die;
}


sub usage {
   print "
usage: vddTester DEBUGGER DEBUGGER COMMAND

A test shell for the vim debugger daemon.  Invocation is weird because it
doesn't want quotes around the DEBUGGER COMMAND.  This is so tab completion
works.

example: vddTester Perl perl -Ilib -d t/Perl.testCode

"; exit(0);
}


sub initializeReadLine {
   $term = new Term::ReadLine('sanity');
   $term->ornaments(0);

   if($term->ReadLine eq 'Term::ReadLine::Gnu') {
      # Term::ReadLine::Gnu specific setup
   }

   if ($term->ReadLine eq 'Term::ReadLine::Stub') {
      warn("neither Term::ReadLine::Gnu or Term::ReadLine::Perl are installed.\n"
        . "please install from CPAN to enable command history or line " 
        . "editing\n")
   }
}

sub init {
   $| = 1;

   getCommandLineOptions();

   $ctl_vddFIFOvim = ".ctl_vddFIFOvim." . $sessionId; # control fifo; write to vdd
   $ctl_vimFIFOvdd = ".ctl_vimFIFOvdd." . $sessionId; # control fifo; read from vim
   $dbg_vddFIFOvim = ".dbg_vddFIFOvim." . $sessionId; # debug   fifo; write to vdd

   unlink $_ for
      $ctl_vddFIFOvim,
      $ctl_vimFIFOvdd,
      $dbg_vddFIFOvim
   ;

   initializeReadLine();
}



sub main {
   spawnProcess("vdd $sessionId $debuggerName @debuggerCommand");
   readFromVDD();

   # loop until request to exit
   while(1) {
      print color("green"), ":";
      my $command = $term->readline("vdd:$debuggerName> ");
         $command = "quit" unless defined $command;

      for ($command)   {
         /^n$/           and $command = "next";
         /^s$/           and $command = "step";
         /^c$/           and $command = "cont";
         /^q$/           and $command = "quit";
         /^r$/           and $command = "restart";
         /^b (.+)$/      and $command = "break:$1:$sourcePath";
         /^B (.+)$/      and $command = "clear:$1:$sourcePath";
         /^l (.+)$/      and $command = "clearAll";
         /^p (.+)$/      and $command = "printExpression:$1";
         /^d (.+)$/      and $command = "command:$1";
      }

      sendToVDD($command);
      exit if $command eq "quit";

      readFromVDD();
   }
}

sub makeNamedPipe {
   my $fifo = shift or die "gotta pass a fifo to this function";

   if (-p $fifo) {
      print "vddTester: $fifo already exists.  perhaps another instance of" .
            " vimDebug is running?\nif not, just delete $fifo.\n";
      exit();
   }

   POSIX::mkfifo($fifo, 0700) or die "mkfifo $fifo failed: $!\n";
}


# blocks until there is something to read
sub readFromVDD {
   sleep 1 until -r $ctl_vddFIFOvim;

   # read from control fifo
print ">>vddTester opening control fifo to read<<\n";
   open my $ctl_hdl, "<", $ctl_vddFIFOvim or die;
   my @msg = <$ctl_hdl>;
   print color("blue"), "received '", @msg, "'", color("white"), "\n";
   close $ctl_hdl;
print ">>vddTester read from control fifo<<\n";

   # read from debug fifo
print ">>vddTester opening debug fifo to read<<\n";
   open my $dbh_hdl, "<", $dbg_vddFIFOvim or die;
   @msg = <$dbh_hdl>;
   print color("blue"), "received '", @msg, "'", color("white"), "\n";
   close $dbh_hdl;
print ">>vddTester read from debug fifo<<\n";
}


# blocks until someone reads
sub sendToVDD {
   my $stuffToSend = (shift or $prevCommand);

   print color("blue"), "sending  '$stuffToSend'", color("white"), "\n";
   open my $ctl_hdl, ">", $ctl_vimFIFOvdd or die;  # blocks until there is a reader
   print {$ctl_hdl} $stuffToSend;
   close $ctl_hdl;

   $prevCommand = $stuffToSend;
}

sub spawnProcess {
   my @incantation = @_ or die;

   die "cannot fork" unless(defined(my $PID = fork));
   if($PID == 0) {
      exec(@incantation) or die "failed to run " . join(' ', @incantation);
   }
}


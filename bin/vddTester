#!/usr/bin/env perl
#
# vddTester
# Vim Debugger Daemon Tester
#
# (c) eric johnson 2002-3020
# email: vimDebug at iijo dot org
# http://iijo.org
# PODNAME: vddTester
# ABSTRACT: Tests the vdd program.

use strict;
use warnings;
use Cwd;
use File::Basename;
use POSIX ();
use Term::ANSIColor;
use Term::ReadLine;

my ($sessionId, $sourcePath, $debuggerName, @debuggerCommand, $fifo); 
my ($term, $PID, $prevCommand);


init();
main();


sub getCommandLineOptions {
   usage() unless(scalar(@ARGV) >= 2);

   $sessionId          = int(rand(99999));
   $debuggerName       = shift @ARGV or die;
   @debuggerCommand    = @ARGV or die;
}


sub usage {
   print "
usage: vddTester DEBUGGER DEBUGGER COMMAND

A test shell for the vim debugger daemon.  Invocation is weird because it
doesn't want quotes around the DEBUGGER COMMAND.  This is so tab completion
works.

example: vddTester Perl perl -Ilib -d t/perl.pl

"; exit(0);
}


sub initializeReadLine {
   $term = new Term::ReadLine('sanity');
   $term->ornaments(0);

   if($term->ReadLine eq 'Term::ReadLine::Gnu') {
      # Term::ReadLine::Gnu specific setup
   }

   if ($term->ReadLine eq 'Term::ReadLine::Stub') {
      warn("neither Term::ReadLine::Gnu or Term::ReadLine::Perl are installed.\n"
        . "please install from CPAN to enable command history or line " 
        . "editing\n")
   }
}

sub init {
   $| = 1;
   getCommandLineOptions();
   $fifo = ".vdd." . $sessionId;
   unlink $fifo;
   initializeReadLine();
}



sub main {
   spawnProcess("vdd $sessionId $debuggerName @debuggerCommand");
   readFromVDD();

   # loop until request to exit
   while(1) {
      print color("green"), ":";
      my $command = $term->readline("vdd:$debuggerName> ");
         $command = "quit" unless defined $command;

      for ($command)   {
         /^n$/           and $command = "next";
         /^s$/           and $command = "step";
         /^c$/           and $command = "cont";
         /^q$/           and $command = "quit";
         /^r$/           and $command = "restart";
         /^b (.+)$/      and $command = "break:$1:$sourcePath";
         /^B (.+)$/      and $command = "clear:$1:$sourcePath";
         /^l (.+)$/      and $command = "clearAll";
         /^p (.+)$/      and $command = "printExpression:$1";
         /^d (.+)$/      and $command = "command:$1";
      }

      sendToVDD($command);
      exit if $command eq "quit";

      readFromVDD();
   }
}

sub makeNamedPipe {
   my $fifo = shift or die "gotta pass a fifo to this function";

   if (-p $fifo) {
      print "vddTester: $fifo already exists.  perhaps another instance of" .
            " vimDebug is running?\nif not, just delete $fifo.\n";
      exit();
   }

   POSIX::mkfifo($fifo, 0700) or die "mkfifo $fifo failed: $!\n";
}


# blocks until there is something to read
sub readFromVDD {
   sleep 1 until -r $fifo;

   # read from control fifo
print ">>vddTester opening control fifo to read<<\n";
   open(my $fifoHandle, "<", $fifo) or die;
   my @msg = <$fifoHandle>;
   print color("blue"), "received '", @msg, "'", color("white"), "\n";
   close($fifoHandle);
print ">>vddTester read from control fifo<<\n";
}


# blocks until someone reads
sub sendToVDD {
   my $data = (shift or $prevCommand);

   print color("blue"), "sending  '$data'", color("white"), "\n";
   open(my $fifoHandle, ">", $fifo) or die;  # blocks until there is a reader
   print {$fifoHandle} $data;
   close($fifoHandle);

   $prevCommand = $data;
}

sub spawnProcess {
   my @incantation = @_ or die;

   die "cannot fork" unless(defined(my $PID = fork));
   if($PID == 0) {
      exec(@incantation) or die "failed to run " . join(' ', @incantation);
   }
}

